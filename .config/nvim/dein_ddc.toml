[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = 'InsertEnter'
hook_source = '''
  " Use around source.
  call ddc#custom#patch_global('sources', ['around','nvim-lsp','file','buffer'])

  " Change source options
  call ddc#custom#patch_global('sourceOptions', {
      \ '_': {
      \   'matchers': ['matcher_fuzzy','matcher_head','matcher_length'],
      \   'sorters': ['sorter_fuzzy','sorter_rank'],
      \   'converters': ['converter_fuzzy']
      \ },
      \ 'around': {'mark': 'A'},
      \ 'nvim-lsp': {'mark': 'lsp','forceCompletionPattern': '\.\w*|:\w*|->\w*' },
      \ 'file': {'mark': 'F', 'isVolatile': v:true,'forceCompletionPattern': '\S/\S*'},
      \ 'buffer': {'mark': 'B'},
      \ })
  call ddc#custom#patch_global('sourceParams', {
      \ 'around': {'maxSize': 500},
      \ 'nvim-lsp': { 'kindLabels': { 'Class': 'c' } },
      \ 'buffer': {'requireSameFiletype': v:false},
      \ })



  " Mappings
  " <TAB>: completion.
  inoremap <silent><expr> <TAB>
  \ pumvisible() ? '<C-n>' :
  \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
  \ '<TAB>' : ddc#manual_complete()

  " <S-TAB>: completion back.
  inoremap <expr><S-TAB>  pumvisible() ? '<C-p>' : '<C-h>'

  " Use ddc.
  call ddc#enable()
'''


[[plugins]]
repo = 'vim-denops/denops.vim'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-nvim-lsp-doc'
on_source = 'ddc-nvim-lsp'
hook_source = '''
  let g:ddc_nvim_lsp_doc_config = {
        \ 'documentation': {
        \   'enable': v:false,
        \   'border': 'rounded',
        \   'maxWidth': 100,
        \   'winblend': 0,
        \ },
        \ 'signature': {
        \   'border': 'rounded',
        \ },
        \ }
  call ddc_nvim_lsp_doc#enable()
'''

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-buffer'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_length'
on_source = 'ddc.vim'


[[plugins]]
repo = 'neovim/nvim-lspconfig' #LSPの設定を行うプラグイン。
on_event = 'BufEnter' #バッファが立ち上がったらプラグインを読み込む。
hook_source = '''
lua << EOF

-- local nvim_lsp = require('lspconfig')

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', 'H', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', '<Leader>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<Leader>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '<Leader>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  buf_set_keymap('n', '<Leader>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '<Leader>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
end

on_attach()

local lsp_installer = require("nvim-lsp-installer")

lsp_installer.on_server_ready(function(server)
    local opts = {}

    -- (optional) Customize the options passed to the server
    -- if server.name == "tsserver" then
    --     opts.root_dir = function() ... end
    -- end

    -- This setup() function is exactly the same as lspconfig's setup function (:help lspconfig-quickstart)
    server:setup(opts)
    vim.cmd [[ do User LspAttachBuffers ]]
end)
  -- disable virtual message (e.g. error, warning)
  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
    vim.lsp.diagnostic.on_publish_diagnostics, { virtual_text = false }
  )

-- 
--  local function setup_servers()
--    require'lspinstall'.setup()
--    local servers = require'lspinstall'.installed_servers()
--    for _, server in pairs(servers) do
--      require'lspconfig'[server].setup{}
--    end
--  end
-- 
--  setup_servers()
-- 
-- -- Automatically reload after `:LspInstall <server>` so we don't have to restart neovim
-- require'lspinstall'.post_install_hook = function ()
--   setup_servers() -- reload installed servers
--   vim.cmd("bufdo e") -- this triggers the FileType autocmd that starts the server
-- end
EOF

'''

# [[plugins]]
# repo = 'kabouzeid/nvim-lspinstall' #vim-lspにおけるvim-lsp-settingsのようなプラグイン。
# on_source = 'nvim-lspconfig'
# hook_source = '''
#   lua require'lspinstall'.setup()
# '''

[[plugins]]
repo = 'williamboman/nvim-lsp-installer'
on_source = 'nvim-lspconfig'
